"""
Parse circuits and generate Lean4 proofs.
Converts Python circuit definitions to Lean4 theorem statements.
"""

import os
import sys
from src.circuit import Circuit

def circuit_to_lean(circuit):
    """
    Convert a Circuit object to Lean4 theorem.
    
    Args:
        circuit: Circuit object
    
    Returns:
        String containing Lean4 code
    """
    
    # Extract variable names
    input_vars = circuit.get_input_vars()
    output_vars = circuit.get_output_vars()
    
    # For simplicity, assume first constraint defines the computation
    # Real implementation would parse this properly
    constraint = circuit.constraints[0]
    
    # Generate Lean4 code
    lean_code = f"""-- Auto-generated proof for circuit: {circuit.name}
-- Description: {circuit.description}
-- Generated by zkEVM Circuit Verifier Prototype

-- Define the circuit function
def {circuit.name}_circuit ({' '.join(f'{v} : Nat' for v in input_vars)}) : Nat :=
  {' + '.join(input_vars) if 'add' in circuit.name or '+' in constraint else ' * '.join(input_vars) if 'multiply' in circuit.name or '*' in constraint else input_vars[0]}

-- Correctness theorem: the circuit computes what we expect
theorem {circuit.name}_correct ({' '.join(f'{v} : Nat' for v in input_vars)}) :
  {circuit.name}_circuit {' '.join(input_vars)} = {' + '.join(input_vars) if 'add' in circuit.name or '+' in constraint else ' * '.join(input_vars) if 'multiply' in circuit.name or '*' in constraint else input_vars[0]} := by
  rfl

-- Soundness property: output matches specification
theorem {circuit.name}_sound ({' '.join(f'{v} : Nat' for v in input_vars + output_vars)})
  (h : {output_vars[0]} = {circuit.name}_circuit {' '.join(input_vars)}) :
  {output_vars[0]} = {' + '.join(input_vars) if 'add' in circuit.name or '+' in constraint else ' * '.join(input_vars) if 'multiply' in circuit.name or '*' in constraint else input_vars[0]} := by
  simp [{circuit.name}_circuit] at h
  exact h

-- Example computation
#eval {circuit.name}_circuit {' '.join(['5', '3'][:len(input_vars)])}

-- Verification status
#check {circuit.name}_correct
#check {circuit.name}_sound
"""
    
    return lean_code

def parse_circuit_file(filepath):
    """
    Load circuit from Python file.
    
    Args:
        filepath: Path to Python file containing Circuit definition
    
    Returns:
        Circuit object
    """
    import importlib.util
    
    # Load the module
    spec = importlib.util.spec_from_file_location("circuit_module", filepath)
    if spec is None or spec.loader is None:
        raise ValueError(f"Could not load module from {filepath}")
    
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    
    # Find Circuit object in module
    for attr_name in dir(module):
        attr = getattr(module, attr_name)
        if isinstance(attr, Circuit):
            return attr
    
    raise ValueError(f"No Circuit object found in {filepath}")

def main():
    """Main entry point for parser"""
    if len(sys.argv) < 2:
        print("Usage: python -m src.parser <circuit_file.py>")
        print("Example: python -m src.parser circuits/add.py")
        sys.exit(1)
    
    circuit_file = sys.argv[1]
    
    if not os.path.exists(circuit_file):
        print(f"Error: File not found: {circuit_file}")
        sys.exit(1)
    
    try:
        # Parse circuit
        circuit = parse_circuit_file(circuit_file)
        print(f"✓ Parsed circuit: {circuit}")
        
        # Generate Lean4 code
        lean_code = circuit_to_lean(circuit)
        
        # Write to proofs/
        os.makedirs("proofs", exist_ok=True)
        output_file = f"proofs/{circuit.name}_proof.lean"
        
        with open(output_file, 'w') as f:
            f.write(lean_code)
        
        print(f"✓ Generated {output_file}")
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
